## --------------------- QUESTÃO 1 -----------------------------

def mudanca_salarial(salario):
    ''''
        Função com um parâmetro de entrada.
        Um float definindo o valor do salário a ser contado

        Calcula o valor do reajuste a partir do valor do salário inserido
        Função sem retorno, apenas prints dos dados obtidos.
        (float) → None
    '''

    if salario <= 3500:  # Se o salário for menor que 3500, o reajuste se dá pelo acréscimo de 9% + um abono de R$200,00.
        return print((salario + 0.09 * salario) + 200)
    else:  # Se o salário for maior que 3500, o reajuste se dá apenas pelo acréscimo de 9%.
        return print((salario + 0.09 * salario))


## --------------------- QUESTÃO 2 -----------------------------

def calculo_agua(metroc):
    ''''
        Função com um parâmetro de entrada.
        Um int chamado metrosc que representa a quantidade de água em m^3

        Calcula o valor a ser pago a partir do valor de m^3 de água inserido.
        Função sem retorno, apenas prints dos dados obtidos.
        (int) → None
    '''
    if metrosc <= 10:  # Se a quantidade for abaixo de 10, o consumidor pagará apenas R$7,00.
        return print("R$7")
    elif metrosc <= 30:  # Se a quantidade for abaixo de 10, o consumidor pagará os R$7,00 + um adicional de R$1,00 a cada m^3 usado a partir de 10 e que seja menor que 30.
        return print(f"O valor é de {7 + 1 * (metrosc - 10)}R$")
    elif metrosc <= 100:  # Se a quantidade for abaixo de 100, o consumidor pagará os R$7,00 + R$20,00 + um adicional de R$2,00 a cada m^3 usado a partir de 30 e que seja menor que 100.
        return print(f"O valor é de {27 + 2 * (metrosc - 30)}R$")
    else:  # Se a quantidade for maior que 100, o consumidor pagará os R$7,00 + R$20,00 + R$140,00 + um adicional de R$5,00 a cada m^3 usado a partir de 100.
        return print(f"O valor é de {167 + 5 * (metrosc - 100)}R$")


## --------------------- QUESTÃO 3 -----------------------------

def calculo_IR(salario, desconto_simplificado=False):
    ''''
        Função com dois parãmetros de entrada:
        Um float definindo o valor do salário a ser contado
        Um bool chamado desconto_simplificado começando com False, indicando que não se contará com o desconto simplificado
        Caso desconto_simplificado = True, contaremos com o desconto simplificado

        Calcula a partir do valor de salário inserido qual é o valor de IR a pagar
        Função sem retorno, apenas prints dos dados obtidos
        (float,bool = False) → None
    '''

    if salario <= 2259.20:  # Se o salário for menor que 2250,20 o IR será 0
        print(f"Isento")

    if desconto_simplificado:
        if salario <= 2826.65:  # Se o salário estiver na faixa de 2250,20 - 2826,65 com o desconto simplificado, o IR será 0
            print(f"Isento")
    else:
        if salario <= 2826.65:  # Se o salário estiver na faixa de 2250,20 - 2826,65 sem o desconto simplificado, o IR será de 7,5% da aliquota de R$169,44
            print(f"A pagar {0.075 * 169.44:.2f}"
                  f"Aliquota de 7,5%")

    if salario <= 3751.05:  # Se o salário estiver na faixa de 2826,65 - 3751,05, o IR será de 15% da aliquota de R$381,44
        print(f"A pagar {0.15 * 381.44:.2f}"
              f"Aliquota de 15%")
    elif salario <= 4664.68:  # Se o salário estiver na faixa de 3751,05 - 4664.68, o IR será de 22,5% da aliquota de R$662,77
        print(f"A pagar {0.225 * 662.77:.2f}"
              f"Aliquota de 22,5%")
    else:  # Se o salário for maior que 4664.68, o IR será de 27,5% da aliquota de R$896
        print(f"A pagar {0.275 * 896:.2f}"
              f"Aliquota de 27,5%")


## --------------------- QUESTÃO 4 -----------------------------

from random import randint  # Importando biblioteca necessária para fazer jogo aleatório.


def jogo_de_dados():
    ''''
        Função sem parâmetros de entrada.
        Um jogo de dados que joga dois dados consecutivamente até obter dois valores iguais
        Função sem retorno, apenas prints do jogo de dados
        None → None
    '''
    print("QUE COMECE O JOGO!!, VAMOS VER QUANTAS VEZES SÃO NECESSÁRIAS PARA DOIS DADOS DAREM O MESMO NÚMERO!")
    n1, n2, i = 0, 1, 0  # Definindo as constantes a serem usadas, n1 é o dado 1, n2 é o dado 2 e i é o contador
    while n1 != n2:  # Para que o jogo comece, n1 e n2 têm que ser diferentes, por isso eles foram declarados com valores distintos
        n1 = randint(1, 6)  # n1 recebe um valor aleatório entre 1 e 6
        print(f'O primeiro dado deu {n1}')
        n2 = randint(1, 6)  # n2 recebe um valor aleatório entre 1 e 6
        print(f'O segundo dado deu {n2}')
        i += 1  # atualiza o contador para a próxima rodada
        print('=-' * 30)

    print(
        f'Boa! Finalmente acabou, foram necessárias {i} tentativas')  # imprime na tela quantas vezes foram necessárias para o jogo acabar


## --------------------- QUESTÃO 5 -----------------------------

import turtle as t  # Importando biblioteca necessária para poder fazer desenhos com python


def estrela(lado, cor='dark blue'):
    ''''
        Função com dois parâmetros de entrada:
        (int, str) → None
        lado = int(valor do lado da estrela)
        cor = str(cor da estrela)/por padrão é dark blue
        Desenha uma estrela a partir dos dados de tamanho de lado e cor de linha
        Função sem retorno, apenas desenhos.
    '''
    t.color(cor)  # Definindo a cor do pincel a ser usada
    i = 0  # configurando o contador
    t.left(18)  # Resolver isso #Começamos virando o pincel para XXXX a YYYY graus
    t.forward(lado)  # Começamos trilhando o primeiro caminho, por conta disso o contador deve ir até n-1, onde n é a
    # quantidade de linhas necessárias para fazer a figura
    while i < 9:
        t.right(72)  # Vira-se para XXXX a YYYY graus
        t.forward(lado)  # Segue reto
        i += 1  # Atualiza o contador


def desenha_ceu(cor='dark blue'):
    ''''
        Função com um parâmetro de entrada:
        (str) → None
        cor = str(cor da estrela)/por padrão é dark blue
        Desenha estrelas de tamanhos aleatórios em locais aleatórios na tela.
        Os tamanhos dos lados das estrelas podem variar de 10 a 50
        A sua área de pintura vai de -500 até +500, tanto no eixo X quanto no eixo Y
        Função sem retorno, apenas desenhos.
    '''
    i = 0  # Configurando o contador
    t.hideturtle()  # Esconde-se o pincel para diminuir a poluição visual
    t.speed('fastest')  # Define que a pintura do pincel será rápida
    t.bgcolor('black')  # define que a cor do plano de fundo será preta
    while i < 100:  # começamos uma contagem até 100, ou seja, serão feitas 100 estrelas aleatórias na tela
        t.up()  # levantamos o pincel para que não suje a tela
        t.goto(randint(-500, 500), randint(-500, 500))  # vamos até uma posição aleatória na tela
        t.down()  # abaixamos o pincel para começar a pintura
        t.begin_fill()  # definimos que a pintura será preenchida pela cor da borda
        estrela(randint(10, 20), cor)  # Chamamos a função estrela para criar uma estrela de tamanho randomico entre
        # 10 e 50 e que tenha a cor escolhida pelo usuário
        t.end_fill()  # Terminanmos de preencher tudo que for desenhado a partir daqui
        i += 1  # atualiza o contador


## --------------------- QUESTÃO 6 -----------------------------

def quadrado(x):
    ''''
        Função com um parâmetro de entrada:
        (int) → None
        x = int(valor do lado do quadrado)
        Desenha um quadrado a partir dos dados de tamanho de lado
        Função sem retorno, apenas desenhos.
    '''
    i = 1  # configuro o contador
    while i <= 4:  # começo uma repetição de 4 contagens em que cada contagem fara um lado do quadrado.
        t.forward(x)  # sigo reta
        t.left(90)  # viro em 90 graus
        i += 1  # atualizo o contador


def tabuleiro(x, cor='red'):
    ''''
         Função com dois parâmetros de entrada:
         (int, str) → None
         x = int(valor do lado do quadrado)
         cor = str(cor da borda do quadrado e por consequência a cor do tabuleiro)/por padrão é red
         Desenha um tabuleiro de xadrez a partir da obtenção do lado x do quadrado usado como base
         Função sem retorno, apenas desenhos.
    '''
    pos_zero_x, pos_zero_y = -4 * x, 4 * x  # Definimos duas variáreis que decidirão a posição 0 do pincel, usada para
    # centralização do tabuleiro na tela
    t.speed('fastest')  # Define que a pintura do pincel será rápida
    t.bgcolor('black')  # Define que a cor do plano de fundo será preta
    t.color(cor)  # Definindo a cor do pincel a ser usada
    t.hideturtle()  # Esconde-se o pincel para diminuir a poluição visual
    i = 0  # Configurando o contador do eixo X
    t.up()  # levantamos o pincel para que não suje a tela
    t.goto(pos_zero_x, pos_zero_y)  ##centralizar o tabuleiro
    t.down()  # abaixamos o pincel para começar a pintura
    while i < 8:  # começamos a contagem para o eixo X
        j = 0  # configurando o contador do eixo Y
        while j < 8:  # começamos a contagem do eixo Y
            if (i + j) % 2 != 1:  # Se a soma (posição de X + posição Y) for par, preencherei o quadrado em questão
                ##Preencher o quadrado
                t.up()
                t.goto((i * x) + pos_zero_x,
                       (-j * x) + pos_zero_y)  # Vamos para a posição atual acrescidos da posição
                # de centralização
                t.down()
                t.begin_fill()
                quadrado(x)  # chama a função para desenhar quadrado
                t.end_fill()
            else:  # Se a soma (posição de X + posição Y) for impar, não preencherei o quadrado em questão
                ##Não preencher o quadrado
                t.up()
                t.goto((i * x) + pos_zero_x,
                       (-j * x) + pos_zero_y)  # Vamos para a posição atual acrescidos da posição
                # de centralização
                t.down()
                quadrado(x)  # chama a função para desenhar quadrado
            j += 1  # atualiza o contador de Y
        i += 1  # atualiza o cotador de X após concluir a contagem de Y


## --------------------- QUESTÃO 7 -----------------------------
def numero_perfeito(n):
    ''''
         Função com um parâmetro de entrada:
         (int) → None
         n = int(número escolhido)
         Verifica se o número digitado como parãmetro de entrada é um número perfeito.
         Um número perfeito é aquele em que a soma dos seus multiplos é igual a ele mesmo.
         Função sem retorno, apenas prints.
    '''
    i, soma = 1, 0  # configurando o contador e definindo uma variável de soma, atribuindo um valor inicial de 0
    while i < n:  # começando a contagem
        if n % i == 0:  # se o valor de i, que é menor que n por obrigação, for um multiplo inteiro de n, a variável soma
            # recebe um acréscimo de i, sendo o valor da variável mais o valor de i.
            soma += i
        i += 1  # atualiza o contador
    if soma == n:  # verificação final, se a variável soma no final se igualar ao número digitado, ele é um número perfeito
        print('O número é perfeito')
    else:  # verificação final, se a variável soma no final não se igualar ao número digitado, ele não é um número perfeito
        print('O número não é perfeito')


## --------------------- QUESTÃO 8 -----------------------------
##Done, só fazer a verificação do 1
def primo(n):
    ''''
         Função com um parâmetro de entrada:
         (int) → (bool)
         n = int(número escolhido)
         Verifica-se se o número inserido é um número primo.
         Um número primo é aquele que só possui dois divisores, o número um e ele próprio
    '''
    i, ct = 2, 0  ##i representa o contador que mostrará os multiplos de n, todo número é divisivel por 1, por isso o contador começa em 2
                  #ct representa a contagem de quantos multiplos inteiros do número n há
    while i <= n: ##
        if n % i == 0: #se i for multiplo de n, adiciona-se uma unidade a ct
            ct += 1
        i += 1
    if ct > 1: #caso o contador de multiplos de n for maior que um, quer dizer que ele não é primo
        return False
    else: #caso o contador de multiplos de for igual a um, quer dizer que ele não é primo
        return True


def soma_primo(n):
    ''''
         Função com um parâmetro de entrada:
         (int) → None
         n = int(número escolhido)
         Faz-se a soma de todos os números primos menores que n.
         Um número primo é aquele que só possui dois divisores, o número um e ele próprio
         Função sem retorno, apenas prints.
    '''
    i, soma = 2, 0 #começa-se definindo um contador coemçando em 2, pois o número 1 não é primo e
                   # uma variável soma que armazenará a soma dos valores primos
    while i < n:
        if primo(i): #se o valor i for um número primo
            soma += i #soma-se ele à variável soma
        i += 1
    return print(soma) #ao final mostramos o valor da soma de todos os números primos menores que n


## --------------------- QUESTÃO 9 -----------------------------

def juros_compostos(p, r, n):
    ''''
         Função com um parâmetro de entrada:
         (float, float, int) → None
         p = float(capital incial)
         r = float(taxa anual de juros)
         n = int(quantidade de anos aplicado)
         Retorna uma tabela mostrando a quantidade de tempo e o retorno em cada ano de uma taxa r aplicada em juros compostos
    '''
    i = 1 #define-se um contador a partir do ano 1
    juros = (1 + (r / 100)) #armazeno na variável juros o valor de juros compostos a ser aplicado
    print('Ano  Saldo na conta')
    while i <= n: #começo a contagem
        p = p * juros
        print(f"{i}  {p:.2f}") #mostro na tela a tabela com os valores e seu respectivos anos
        i += 1 #atualizo o contador


## --------------------- QUESTÃO 10-----------------------------
##Perguntar sobre essa questão
def juros_compostos_V2(p,
                       objetivo,
                       anos,
                       meses,
                       r=0.5,
                       month=True):
    i = 1
    if month:
        ##Caso mes for True, a taxa é mensal
        juros = (1 + (r / 100))
        meses = meses + anos * 12
        print('Mes  Saldo na conta')
        while i <= meses:
            p = p * juros
            print(f"{i}  {p:.2f}")
            i += 1
        if p < objetivo:
            print('Com o tempo investido, não foi possível chegar no valor objetivo,'
                  'a seguir seguirá uma tabela demonstando quanto tempo mais serria necessário para '
                  'alcançá-lo')
            while p < objetivo:
                print('Mes  Saldo na conta')
                p = p * juros
                print(f"{i}  {p:.2f}")
        else:
            print('O obejtivo foi alcançado')
    else:
        ##Caso mes for false, a taxa é anual
        juros = (1 + (r / 100))
        anos = anos + meses / 12
        print('Ano  Saldo na conta')
        while i <= anos:
            p = p * juros
            print(f"{i}  {p:.2f}")
            i += 1
        if p < objetivo:
            print('Com o tempo investido, não foi possível chegar no valor objetivo,'
                  'a seguir seguirá uma tabela demonstando quanto tempo mais serria necessário para '
                  'alcançá-lo')
            while p < objetivo:
                print('Ano  Saldo na conta')
                p = p * juros
                print(f"{i}  {p:.2f}")
        else:
            print('O obejtivo foi alcançado')
